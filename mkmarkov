#!/usr/bin/python

from monop.estate import Estate
from monop.estategroup import EstateGroup
from monop.card import Card

import numpy as np
import math

JAIL_ROLLS = 3

class GameConf(object):
	def load(self, f):
		self.groupidx = {}
		self.groups = []
		self.estates = []
		self.cards = {}
		self.params = {}
		self.jail = 10
		self.tojail = 30
		def General(params, sec):
			for k,v in params:
				self.params[k] = v
		def EstateGroups(params, secs):
			for h, b in secs:
				g = EstateGroup()
				g.name = h
				for k, v in b:
					setattr(g, k, v)
				self.groupidx[g.name] = len(self.groups)
				self.groups.append(g)

		def Estates(params, secs):
			for h, b in secs:
				e = Estate()
				e.name = h
				for k, v in b:
					if k == 'group':
						v = self.groupidx.get(v, -1)
					setattr(e, k, v)
				if e.jail:
					self.jail = len(self.estates)
				if e.tojail:
					self.tojail = len(self.estates)
				self.estates.append(e)

		def Cards(params, secs):
			gn = None
			for k,v in params:
				if k == 'groupname':
					gn = v
			for h,b in secs:
				c = Card()
				c.name = h
				for k, v in b:
					setattr(c, k, v)
				self.cards.setdefault(gn, list()).append(c)


		params = []
		secs = []
		k = None
		vals = []
		sec = None
		while True:
			l = f.readline()
			if l == '':
				break
			l = l.rstrip('\r\n')
			if l == '':
				continue
			if l[0] == '#':
				continue

			sections = {
				'<General>':General,
				'<EstateGroups>':EstateGroups,
				'<Board>':None,
				'<Cards>':Cards,
				'<Estates>':Estates,
			}
			if l[0] == '<':
				if k is None:
					params.extend(vals)
				else:
					secs.append((k, vals))
				vals = []
				k = None
				if sec is not None:
					sec(params, secs)
				params = []
				secs = []
				sec = sections.get(l, None)
			elif l[0] == '[':
				if k is None:
					params.extend(vals)
				else:
					secs.append((k, vals))
				vals = []
				k = l[1:-1]
			else:
				arr = l.split('=')
				assert(len(arr) == 2)
				vals.append((arr[0], arr[1]))
		secs.append((k, vals))
		if sec is not None:
			sec(params, secs)

	def __init__(self, f = None):
		super(GameConf, self).__init__()
		self.groups = []
		self.estates = []
		if f is not None:
			self.load(f)

class Roll(object):
	def __init__(self):
		super(Roll, self).__init__()
		r = [0 for x in xrange(6 * 2 + 2)] # 0 and 1 not possible
		d = [0 for x in xrange(6 * 2 + 2)]
		for i in xrange(1,7):
			for j in xrange(1,7):
				if i == j:
					d[i + j] += 1
				else:
					r[i + j] += 1
		self.__out = []
		space = float(6 * 6)
		for score, (rr, dd) in enumerate(zip(r, d)):
			if not rr and not dd:
				continue
			self.__out.append((score, rr/space, dd/space))
		#sum([sum((x, y)) for (a,x,y) in self.__out]) == 1.0

	# return list of tuples of (score, Pr, Pd) representing
	# the set of all possible dice outcomes where:
	#  - score = sum of dice face values
	#  - Pr = probability of rolling this NOT as doubles
	#  - Pd = probability of rolling this as doubles
	def outcomes(self):
		return self.__out

class Cards(object):
	def __init__(self, deck):
		super(Cards, self).__init__()

class Universe(frozenset):
	def __new__(cls, card):
		return super(Universe, cls).__new__(cls, xrange(card))

class Graph(dict):
	def __init__(self, U):
		super(Graph, self).__init__()
		assert(isinstance(U, Universe))
		self.U = U

	def __getitem__(self, (x,y)):
		assert(x < len(self.U))
		assert(y < len(self.U))
		try:
			return super(Graph, self).__getitem__((x,y))
		except KeyError:
			return 0.0

	def __setitem__(self, (x,y), v):
		if not isinstance(v, float):
			raise TypeError
		super(Graph, self).__setitem__((x,y), v)
	
	def __str__(self):
		rows = []
		for i in xrange(len(self.U)):
			r = ' '.join(map(lambda x:'%.3f'%self[i,x],
					xrange(len(self.U))))
			rows.append(r)
		return '\n'.join(rows)

	def image(self, n):
		assert(n < len(self.U))
		ret = []
		for i in xrange(len(self.U)):
			if self[n,i]:
				ret.append(i)
		return frozenset(ret)

	def preimage(self, n):
		assert(n < len(self.U))
		ret = []
		for i in xrange(len(self.U)):
			if self[i,n]:
				ret.append(i)
		return frozenset(ret)

	def check(self):
		return True

	def dump(self, fn, names = None):
		def q(s):
			return '\"%s\"'%s
		f = open(fn, 'w')
		f.write('digraph %s {\n'%q('Monopoly Markov Model'))
		f.write('\tgraph[rankdir=LR]\n')
		f.write('\tnode [shape = rectangle];\n')
		f.write('\n')
		def add_node(n, **kwargs):
			n = q(n)
			a = ' '.join(map(lambda (k,v):'%s=%s'%(k, q(v)),
					kwargs.items()))
			f.write('%s [%s];\n'%(n,a))
		def add_edge(pre, post, label):
			pre = q(pre)
			post = q(post)
			label = q(label)
			f.write('%s -> %s [label=%s];\n'%(pre, post, label))

		if names is None:
			names = map(lambda x:'%d'%x, sorted(self.U))
		for v in self.U:
			add_node(v, label=names[v])

		for (pre, post), val in self.items():
			add_edge(pre, post, label='%g'%val)

		f.write('}\n')
		f.close()


def find_next(gn, ni, c):
	for i in xrange(ni, len(c.estates)):
		if c.estates[i].group < 0:
			continue
		g = c.groups[c.estates[i].group]
		if gn != g.name:
			continue
		return i
	for i in xrange(len(c.estates)):
		if c.estates[i].group < 0:
			continue
		g = c.groups[c.estates[i].group]
		if gn != g.name:
			continue
		return i
	return None

def go_out(state, v, p, is_double, c, rij, closure):
	i = state / JAIL_ROLLS
	d = state % JAIL_ROLLS
	e = c.estates[i]

	# if we're on go-to-jail, that means in-jail, the doubles counter
	# represents the amount of time spent in there.
	if i == c.tojail:
		# for rij we bump the stay-counter for every non doubles turn
		if rij and not is_double:
			ni = i
			nd = d + 1
			# if we tried JAIL_ROLLS times, then move to
			# just-visting
			if nd >= JAIL_ROLLS:
				ni = c.jail
				nd = 0
		elif not rij or is_double:
			# pay out at start of turn for lj strategy, or if
			# we rolled a double in rij then it's the same thing
			ni = c.jail + v
			nd = 0
	else:
		ni = i + v
		nd = is_double and d + 1 or 0

		# go to jail on 3rd double
		if nd >= JAIL_ROLLS:
			ni = c.tojail

		# If we land in jail, reset the doubles counter
		if ni == c.tojail:
			nd = 0

	ni %= len(c.estates)
	nxt = ni * JAIL_ROLLS + nd
	ne = c.estates[ni]

	# If the target has e.takecard then we need to figure out
	# cumulative probabilities for card moves.
	if ne.takecard:
		cardlist = c.cards[ne.takecard]
		for card in cardlist:
			if card.tojail:
				x = c.tojail
			elif card.advanceto >= 0:
				x = card.advanceto
			elif card.advance:
				x = ni + card.advance
			elif card.advancetonextof:
				gn = card.advancetonextof
				x = find_next(gn, ni, c)
			else:
				x = ni

			if x < 0:
				x = len(c.estates) - (abs(x) + 1)
			if x == c.tojail:
				y = 0
			else:
				y = nd

			np = (p * (1.0/len(cardlist)))
			x %= len(c.estates)
			nxt = x * JAIL_ROLLS + y
			#print np, c.estates[x], y
			closure(nxt, np)
		#print
	else:
		closure(nxt, p)

def build_model(dice, c, rij = True):
	s = []
	for i, e in enumerate(c.estates):
		for d in xrange(JAIL_ROLLS):
			n = '%d_%d_'%(i, d) + e.name.replace(' ','_')
			s.append(n)
		#print ' o', i, e.name

	u = Universe(len(s))
	g = Graph(u)

	for ns, n in enumerate(s):
		out = {}
		def closure(nxt, p):
			assert(nxt < len(s))
			out[nxt] = out.get(nxt, 0.0) + p

		for v, Pr, Pd in dice.outcomes():
			if Pr:
				go_out(ns, v, Pr, False, c, rij, closure)
			if Pd:
				go_out(ns, v, Pd, True, c, rij, closure)

		#print n
		for v, k in sorted([(v,k) for (k,v) in out.items()]):
			#print v, s[k]
			g[ns, k] = v
		#print sum(out.values())
		#print
	g.dump('markov%s.dot'%(rij and 'rij' or 'lj'), s)
	return g

def mag_manhattan(a, b):
	return np.sum(a - b)
def mag_euclidian(a, b):
	return np.linalg.norm(a - b)

def do_pagerank(A, k, d, epsilon=1e-5):
	n = A.shape[0]
	r = np.mat([[1.0 for x in k]])
	t = np.mat([[1.0 for x in k]])
	isr = True
	cnt = 0
	mag = mag_euclidian
	#mag = mag_manhattan

	while True:
		if isr:
			np.dot(t, A, r[0])
			t[0] *= d
			t[0] += k
		else:
			np.dot(r, A, t[0])
			r[0] *= d
			r[0] += k
		cnt += 1

		if mag(r, t) <= epsilon:
			break

		isr = not isr

	if not isr:
		r = t

	print 'found after %d iterations'%cnt
	ret = r[0] * (1.0 / r[0].sum())
	return ret.tolist()[0]

def pagerank(A, damping_factor = 0.85):
	n = A.shape[0]
	c = (1.0 - damping_factor) / float(n)
	k = [c for x in xrange(n)]
	return do_pagerank(A, k, damping_factor)

def eigenvector(A):
	n = A.shape[0]
	k = [0.0 for x in xrange(n)]
	return do_pagerank(A, k, 1.0)


def steady_state(g, c):
	A = np.mat(np.zeros([len(g.U), len(g.U)]))
	for (x,y), v in g.items():
		A[x,y] = v

	#pr = pagerank(A)
	pr = eigenvector(A)

	e = {}
	g = {}
	for i,v in enumerate(pr):
		idx = i / 3
		gdx = c.estates[idx].group
		if gdx < 0:
			gdx = -idx
		e[idx] = e.get(idx, 0.0) + v
		g[gdx] = g.get(gdx, 0.0) + v

	for v, k in sorted([(v,k) for (k,v) in e.items()], reverse=True):
		print '%.3f%% %s'%(v * 100.0, c.estates[k].name)
	print
	for v, k in sorted([(v,k) for (k,v) in g.items()], reverse=True):
		if k < 0:
			n = c.estates[-k].name
		else:
			n = c.groups[k].name
		print '%.3f%% %s'%(v * 100.0, n)
	return

def main(argv):
	EXIT_SUCCESS = 0
	EXIT_FAILURE = 1

	#print 'Dice roll probabilities:'
	r = Roll()
	#for x in r.outcomes():
	#	print ' o', x
	#print

	c = GameConf(open(argv[1]))

	g = build_model(r, c, rij = True)
	print 'Steady state probabilities for RIJ model'
	steady_state(g, c)

	print

	g = build_model(r, c, rij = False)
	print 'Steady state probabilities for LJ model'
	steady_state(g, c)

	return EXIT_SUCCESS

if __name__ == '__main__':
	from sys import argv
	raise SystemExit, main(argv)
